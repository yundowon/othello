#include <stdio.h>
#include <stdlib.h>
#define N 6
/* up, down, left, right, upright, upleft, downright, downleft 
	방향에 따라 각각 돌을 둘 수 있는지 확인*/
int gameboard[N][N];

int up_black(int x, int y)
{
	int i;
		
	if(x-1 < 0)  //한칸 위가 모서리인지 확인 
		return 1; //돌을 둘 수 없음 
	else
	{
		if(gameboard[x-1][y] == 'X') //이웃한 칸이 같은 흑돌
			return 1; //돌을 둘 수 없음 
		else if(gameboard[x-1][y] == ' ') //이웃한 칸이 빈칸 
			return 1; //돌을 둘 수 없음 
		else
		{
			if(gameboard[x-1][y] == 'O') //이웃한 칸이 백돌이라면
			{
				for(i=0; i<N; i++)
				{
 					if(x-2-i < 0) //위로 이웃한 칸이 모서리면 
						break; //반복문 빠져나옴 
					if(gameboard[x-2-i][y] == ' ') //위로 이웃한 칸이 빈칸이라면 
						break; //반복문 빠져나옴 
 					if(gameboard[x-2-i][y] == 'O') //위로 이웃한 칸이 백돌이라면 
						continue; //다음 반복으로 
 					if(gameboard[x-2-i][y] == 'X') //위로 이웃한 칸이 흑돌이라면 
						return 0; //돌을 둘 수 있음 
				}
				return 1; //돌을 둘 수 없음 
			}	
		}
	}
}

int down_black(int x, int y)
{
	int i;
	
	if(x+1 >= N)  //한칸 아래가 모서리인지 확인
		return 1; //돌을 둘 수 없음 
	else
	{
		if(gameboard[x+1][y] == 'X') //이웃한 칸이 같은 흑돌
			return 1; //돌을 둘 수 없음 
		else if(gameboard[x+1][y] == ' ') //이웃한 칸이 빈칸 
			return 1; //돌을 둘 수 없음 
		else
		{
			if(gameboard[x+1][y] == 'O') //이웃한 칸이 백돌이라면
			{
				for(i=0; i<N; i++)
				{
 					if(x+2+i >= N) //아래로 이웃한 칸이 모서리면 
						break; //반복문 빠져나옴
					if(gameboard[x+2+i][y] == ' ') //아래로 이웃한 칸이 빈칸이라면
						break; //반복문 빠져나옴
 					if(gameboard[x+2+i][y] == 'O') //아래로 이웃한 칸이 백돌이라면
						continue; //다음 반복으로
 					if(gameboard[x+2+i][y] == 'X') //아래로 이웃한 칸이 흑돌이라면
						return 0; //돌을 둘 수 있음 
				}
				return 1; //돌을 둘 수 없음 
			}	
		}
	}
}

int left_black(int x, int y)
{
	int i;
	
	if(y-1<0)  //한칸 왼쪽이 모서리인지 확인
		return 1; //돌을 둘 수 없음 
	else
	{
		if(gameboard[x][y-1] == 'X') //이웃한 칸이 같은 흑돌
			return 1; //돌을 둘 수 없음 
		else if(gameboard[x][y-1] == ' ') //이웃한 칸이 빈칸 
			return 1; //돌을 둘 수 없음 
		else
		{
			if(gameboard[x][y-1] == 'O') //이웃한 칸이 백돌이라면
			{
				for(i=0; i<N; i++)
				{
 					if(y-2-i < 0) //왼쪽으로 이웃한 칸이 모서리면
						break; //반복문 빠져나옴
					if(gameboard[x][y-2-i] == ' ') //왼쪽으로 이웃한 칸이 빈칸이라면
						break; //반복문 빠져나옴
 					if(gameboard[x][y-2-i] == 'O') //왼쪽으로 이웃한 칸이 백돌이라면
						continue; //다음 반복으로
 					if(gameboard[x][y-2-i] == 'X') //왼쪽로 이웃한 칸이 흑돌이라면
						return 0; //돌을 둘 수 있음 
				}
				return 1; //돌을 둘 수 없음 
			}	
		}
	}
}

int right_black(int x, int y)
{
	int i;
	
	if(y+1 >= N)  //한칸 오른쪽이 모서리인지 확인
		return 1; //돌을 둘 수 없음 
	else
	{
		if(gameboard[x][y+1] == 'X') //이웃한 칸이 같은 흑돌
			return 1; //돌을 둘 수 없음 
		else if(gameboard[x][y+1] == ' ') //이웃한 칸이 빈칸 
			return 1; //돌을 둘 수 없음 
		else
		{
			if(gameboard[x][y+1] == 'O') //이웃한 칸이 백돌이라면
			{
				for(i=0; i<N; i++)
				{
 					if(y+2+i >= N) //오른쪽으로 이웃한 칸이 모서리면
						break; //반복문 빠져나옴
					if(gameboard[x][y+2+i] == ' ') //오른쪽으로 이웃한 칸이 빈칸이라면
						break; //반복문 빠져나옴
 					if(gameboard[x][y+2+i] == 'O') //오른쪽으로 이웃한 칸이 백돌이라면
						continue; //다음 반복으로
 					if(gameboard[x][y+2+i] == 'X') //오른쪽으로 이웃한 칸이 흑돌이라면
						return 0; //돌을 둘 수 있음 
				}
				return 1; //돌을 둘 수 없음 
			}	
		}
	}
}

int upright_black(int x, int y)
{
	int i;
	
	if((x-1 < 0)||(y+1 >= N))  //한칸 위, 한칸 오른쪽이 모서리인지 확인
		return 1; //돌을 둘 수 없음 
	else
	{
		if(gameboard[x-1][y+1] == 'X') //이웃한 칸이 같은 흑돌
			return 1; //돌을 둘 수 없음 
		else if(gameboard[x-1][y+1] == ' ') //이웃한 칸이 빈칸 
			return 1; //돌을 둘 수 없음 
		else
		{
			if(gameboard[x-1][y+1] == 'O') //이웃한 칸이 백돌이라면
			{
				for(i=0; i<N; i++)
				{
 					if((x-2-i < 0)||(y+2+i >= N)) //오른쪽 위로 이웃한 칸이 모서리면
						break; //반복문 빠져나옴
					if(gameboard[x-2-i][y+2+i] == ' ') //오른쪽 위로 이웃한 칸이 빈칸이라면
						break; //반복문 빠져나옴
 					if(gameboard[x-2-i][y+2+i] == 'O') //오른쪽 위로 이웃한 칸이 백돌이라면
						continue; //다음 반복으로
 					if(gameboard[x-2-i][y+2+i] == 'X') //오른쪽 위로 이웃한 칸이 흑돌이라면
						return 0; //돌을 둘 수 있음 
				}
				return 1; //돌을 둘 수 없음 
			}	
		}
	}
}

int upleft_black(int x, int y)
{
	int i;
	
	if((x-1 < 0)||(y-1 < 0))  //한칸 위, 한칸 왼쪽이 모서리인지 확인
		return 1; //돌을 둘 수 없음 
	else
	{
		if(gameboard[x-1][y-1] == 'X') //이웃한 칸이 같은 흑돌
			return 1; //돌을 둘 수 없음 
		else if(gameboard[x-1][y-1] == ' ') //이웃한 칸이 빈칸 
			return 1; //돌을 둘 수 없음 
		else
		{
			if(gameboard[x-1][y-1] == 'O') //이웃한 칸이 백돌이라면
			{
				for(i=0; i<N; i++)
				{
 					if((x-2-i < 0)||(y-2-i < 0)) //왼쪽 위로 이웃한 칸이 모서리면
						break; //반복문 빠져나옴
					if(gameboard[x-2-i][y-2-i] == ' ') //왼쪽 위로 이웃한 칸이 빈칸이라면
						break; //반복문 빠져나옴
 					if(gameboard[x-2-i][y-2-i] == 'O') //왼쪽 위로 이웃한 칸이 백돌이라면
						continue; //다음 반복으로
 					if(gameboard[x-2-i][y-2-i] == 'X') //왼쪽 위로 이웃한 칸이 흑돌이라면
						return 0; //돌을 둘 수 있음 
				}
				return 1; //돌을 둘 수 없음 
			}	
		}
	}
}

int downright_black(int x, int y)
{
	int i;
	
	if((x+1 >= N)||(y+1 >= N))  //한칸 아래, 한칸 오른쪽이 모서리인지 확인
		return 1; //돌을 둘 수 없음 
	else
	{
		if(gameboard[x+1][y+1] == 'X') //이웃한 칸이 같은 흑돌
			return 1; //돌을 둘 수 없음 
		else if(gameboard[x+1][y+1] == ' ') //이웃한 칸이 빈칸 
			return 1; //돌을 둘 수 없음 
		else
		{
			if(gameboard[x+1][y+1] == 'O') //이웃한 칸이 백돌이라면
			{
				for(i=0; i<N; i++)
				{
 					if((x+2+i >= N)||(y+2+i >= N)) //오른쪽 아래로 이웃한 칸이 모서리면
						break; //반복문 빠져나옴
					if(gameboard[x+2+i][y+2+i] == ' ') //오른쪽 아래로 이웃한 칸이 빈칸이라면
						break; //반복문 빠져나옴
 					if(gameboard[x+2+i][y+2+i] == 'O') //오른쪽 아래로 이웃한 칸이 백돌이라면
						continue; //다음 반복으로
 					if(gameboard[x+2+i][y+2+i] == 'X') //오른쪽 아래로 이웃한 칸이 흑돌이라면
						return 0; //돌을 둘 수 있음 
				}
				return 1; //돌을 둘 수 없음 
			}	
		}
	}
}

int downleft_black(int x, int y)
{
	int i;
	
	if((x+1 >= N)||(y-1 < 0))  //한칸 아래, 한칸 왼쪽이 모서리인지 확인
		return 1; //돌을 둘 수 없음 
	else
	{
		if(gameboard[x+1][y-1] == 'X') //이웃한 칸이 같은 흑돌
			return 1; //돌을 둘 수 없음 
		else if(gameboard[x+1][y-1] == ' ') //이웃한 칸이 빈칸 
			return 1; //돌을 둘 수 없음 
		else
		{
			if(gameboard[x+1][y-1] == 'O') //이웃한 칸이 백돌이라면
			{
				for(i=0; i<N; i++)
				{
 					if((x+2+i >= N)||(y-1-i < 0)) //왼쪽 아래로 이웃한 칸이 모서리면
						break; //반복문 빠져나옴
					if(gameboard[x+2+i][y-1-i] == ' ') //왼쪽 아래로 이웃한 칸이 빈칸이라면
						break; //반복문 빠져나옴
 					if(gameboard[x+2+i][y-1-i] == 'O') //왼쪽 아래로 이웃한 칸이 백돌이라면
						continue; //다음 반복으로
 					if(gameboard[x+2+i][y-1-i] == 'X') //왼쪽 아래로 이웃한 칸이 흑돌이라면
						return 0; //돌을 둘 수 있음 
				}
				return 1; //돌을 둘 수 없음 
			}	
		}
	}
}

/* up(=u), down(=d), left(=l), right(=r),
	upright(=ur), upleft(=ul), downright(=dr), downleft(=dl) 
	돌을 놓을 수 있는지 방향 별로 체크 */
int check_black(int a, int b)
{
	int u, d, l, r, ur, ul, dr, dl;
	
	u = up_black(a, b);
	d = down_black(a, b);
	l = left_black(a, b);
	r = right_black(a, b);
	ur = upright_black(a, b);
	ul = upleft_black(a, b);
	dr = downright_black(a, b);
	dl = downleft_black(a, b);
	
	if(gameboard[a][b] != ' ') // 빈칸이 아니면
		return 1; //돌을 둘 수 없음 
	else
	{
		if(u == 0||d == 0||l == 0||r == 0||ur == 0||ul == 0||dr == 0||dl == 0) 
				//return이 0인 방향(돌을 놓을 수 있음)이 하나라도 있다면
			return 0; //진행 
		else
			return 1; //패스 
	}
}
